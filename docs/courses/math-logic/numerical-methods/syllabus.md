# Numerical Methods
**Pillar:** Math & Logic  
**Purpose:** Compute approximate solutions to models when closed-form answers don’t exist.

## Learning Outcomes
1. Implement root-finding, interpolation, and numerical integration.
2. Solve linear systems numerically; understand conditioning.
3. Integrate ODEs numerically (Euler, RK methods).
4. Analyze error, stability, and convergence.

## Modules & Weekly Topics
1. **Root Finding** — bisection, Newton; stopping criteria.
2. **Linear Systems** — Gaussian elimination; LU; conditioning & error.
3. **Interpolation & Quadrature** — polynomials; Simpson/Trap.
4. **ODE Solvers** — Euler, Runge–Kutta; step-size control.
5. **Floating-Point & Stability** — machine epsilon; round-off.
6. **Integration** — mini-capstone: solver showdown for a model problem.

## Resources
- **Primary:** Sauer, *Numerical Analysis*.
- **Tooling:** Python (NumPy/SciPy), Jupyter.

## Assignments & Evaluation
- **Problem Sets:** 5 computational sets.
- **Project:** Numerical experiment with code + write-up.
- **Integration:** Why the chosen method is appropriate; risks.
- **Weighting:** PS 50%, Project 40%, Integration 10%.

## Portfolio Output
- Code + report in `portfolio/`.
